{
  "version": 3,
  "sources": ["../../node_modules/pixi.js/src/events/FederatedEvent.ts", "../../node_modules/ismobilejs/src/isMobile.ts", "../../node_modules/pixi.js/src/utils/browser/isMobile.ts", "../../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts", "../../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts", "../../node_modules/pixi.js/src/events/EventTicker.ts", "../../node_modules/pixi.js/src/events/FederatedMouseEvent.ts", "../../node_modules/pixi.js/src/events/FederatedPointerEvent.ts", "../../node_modules/pixi.js/src/events/FederatedWheelEvent.ts", "../../node_modules/pixi.js/src/events/EventBoundary.ts", "../../node_modules/pixi.js/src/events/EventSystem.ts", "../../node_modules/pixi.js/src/events/FederatedEventTarget.ts"],
  "sourcesContent": ["import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible {@code Touch} event.\n * @memberof events\n */\nexport interface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n\n/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.\n * @typeParam N - The type of native event held.\n * @memberof events\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. {@code \"mouseup\"}. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The {@code target} is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated @code{InteractionEvent.data}.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /** Prevent default behavior of PixiJS and the user agent. */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any addition listeners, including on the\n     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n     * event targets on the propagation path.\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    public readonly NONE = 0;\n    public readonly CAPTURING_PHASE = 1;\n    public readonly AT_TARGET = 2;\n    public readonly BUBBLING_PHASE = 3;\n}\n", "const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n", "import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the {@link utils.isMobile} function.\n * @ignore\n * @memberof utils\n */\nexport type isMobileResult = {\n    /**\n     * Whether the device is an Apple device.\n     * @memberof utils.isMobile\n     */\n    apple: {\n        phone: boolean;\n        ipod: boolean;\n        tablet: boolean;\n        universal: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Amazon device.\n     * @memberof utils.isMobile\n     */\n    amazon: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Android device.\n     * @memberof utils.isMobile\n     */\n    android: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a Windows device.\n     * @memberof utils.isMobile\n     */\n    windows: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a specific device.\n     * @memberof utils.isMobile\n     */\n    other: {\n        blackberry: boolean;\n        blackberry10: boolean;\n        opera: boolean;\n        firefox: boolean;\n        chrome: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a phone device.\n     * @memberof utils.isMobile\n     */\n    phone: boolean;\n    /**\n     * Whether the device is a tablet device.\n     * @memberof utils.isMobile\n     */\n    tablet: boolean;\n    /**\n     * Whether the device is any kind of device.\n     * @memberof utils.isMobile\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * ```js\n * import { isMobile } from 'pixi.js';\n *\n * if (isMobile.apple.tablet) {\n *    // The device is an Apple tablet device.\n * }\n * ```\n * @memberof utils\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n", "import { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/**\n * The accessibility module recreates the ability to tab and have content read by screen readers.\n * This is very important as it can possibly help people with disabilities access PixiJS content.\n *\n * This module is a mixin for {@link AbstractRenderer} and will need to be imported if you are managing your own renderer.\n * Usage:\n * ```js\n * import 'pixi.js/accessibility';\n * ```\n * To make an object accessible do the following:\n * ```js\n * container.accessible = true; // object is now accessible to screen readers!\n * ```\n * See {@link accessibility.AccessibleOptions} for more accessibility related properties that can be set.\n * @namespace accessibility\n */\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/** @ignore */\nexport interface AccessibilityOptions\n{\n    /** Setting this to true will visually show the divs. */\n    debug?: boolean;\n}\n\n/**\n * The Accessibility system recreates the ability to tab and have content read by screen readers.\n * This is very important as it can possibly help people with disabilities access PixiJS content.\n *\n * A Container can be made accessible just like it can be made interactive. This manager will map the\n * events as if the mouse was being used, minimizing the effort required to implement.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.accessibility`\n * @memberof accessibility\n */\nexport class AccessibilitySystem implements System<AccessibilityOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /** Setting this to true will visually show the divs. */\n    public debug = false;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.\n        const div = document.createElement('div');\n\n        div.style.width = `${DIV_TOUCH_SIZE}px`;\n        div.style.height = `${DIV_TOUCH_SIZE}px`;\n        div.style.position = 'absolute';\n        div.style.top = `${DIV_TOUCH_POS_X}px`;\n        div.style.left = `${DIV_TOUCH_POS_Y}px`;\n        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n\n        this._div = div;\n        this._renderer = renderer;\n\n        /**\n         * pre-bind the functions\n         * @type {Function}\n         * @private\n         */\n        this._onKeyDown = this._onKeyDown.bind(this);\n\n        /**\n         * pre-bind the functions\n         * @type {Function}\n         * @private\n         */\n        this._onMouseMove = this._onMouseMove.bind(this);\n\n        // let listen for tab.. once pressed we can fire up and show the accessibility layer\n        globalThis.addEventListener('keydown', this._onKeyDown, false);\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @member {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @member {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        globalThis.removeEventListener('keydown', this._onKeyDown, false);\n\n        this._renderer.runners.postrender.add(this);\n        this._renderer.view.canvas.parentNode?.appendChild(this._div);\n    }\n\n    /**\n     * Deactivating will cause the Accessibility layer to be hidden.\n     * This is called when a user moves the mouse.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        globalThis.addEventListener('keydown', this._onKeyDown, false);\n\n        this._renderer.runners.postrender.remove(this);\n        this._div.parentNode?.removeChild(this._div);\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        if (container.accessible && container.isInteractive())\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilityOptions)\n    {\n        this.debug = options?.debug ?? this.debug;\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.\n     * Only fires while active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // update children...\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n\n        const { x, y, width, height } = this._renderer.view.canvas.getBoundingClientRect();\n        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;\n\n        const sx = (width / viewWidth) * resolution;\n        const sy = (height / viewHeight) * resolution;\n\n        let div = this._div;\n\n        div.style.left = `${x}px`;\n        div.style.top = `${y}px`;\n        div.style.width = `${viewWidth}px`;\n        div.style.height = `${viewHeight}px`;\n\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (child._renderId !== this._renderId)\n            {\n                child._accessibleActive = false;\n\n                removeItems(this._children, i, 1);\n                this._div.removeChild(child._accessibleDiv);\n                this._pool.push(child._accessibleDiv);\n                child._accessibleDiv = null;\n\n                i--;\n            }\n            else\n            {\n                // map div to display..\n                div = child._accessibleDiv;\n                let hitArea = child.hitArea as Rectangle;\n                const wt = child.worldTransform;\n\n                if (child.hitArea)\n                {\n                    div.style.left = `${(wt.tx + (hitArea.x * wt.a)) * sx}px`;\n                    div.style.top = `${(wt.ty + (hitArea.y * wt.d)) * sy}px`;\n\n                    div.style.width = `${hitArea.width * wt.a * sx}px`;\n                    div.style.height = `${hitArea.height * wt.d * sy}px`;\n                }\n                else\n                {\n                    hitArea = child.getBounds().rectangle;\n\n                    this._capHitArea(hitArea);\n\n                    div.style.left = `${hitArea.x * sx}px`;\n                    div.style.top = `${hitArea.y * sy}px`;\n\n                    div.style.width = `${hitArea.width * sx}px`;\n                    div.style.height = `${hitArea.height * sy}px`;\n\n                    // update button titles and hints if they exist and they've changed\n                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null)\n                    {\n                        div.title = child.accessibleTitle || '';\n                    }\n                    if (div.getAttribute('aria-label') !== child.accessibleHint\n                        && child.accessibleHint !== null)\n                    {\n                        div.setAttribute('aria-label', child.accessibleHint || '');\n                    }\n                }\n\n                // the title or index may have changed, if so lets update it!\n                if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex)\n                {\n                    div.title = child.accessibleTitle || '';\n                    div.tabIndex = child.tabIndex;\n                    if (this.debug)\n                    {\n                        this._updateDebugHTML(div);\n                    }\n                }\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Adds a Container to the accessibility manager\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        //    this.activate();\n\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            div = document.createElement('button');\n\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        container._accessibleDiv.tabIndex = container.tabIndex;\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /** Destroys the accessibility manager */\n    public destroy(): void\n    {\n        this._destroyTouchHook();\n        this._div = null;\n\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        globalThis.removeEventListener('keydown', this._onKeyDown);\n\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n    }\n}\n", "import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * Can be any of the following:\n * - `auto`\n * - `none`\n * - `visiblePainted`\n * - `visibleFill`\n * - `visibleStroke`\n * - `visible`\n * - `painted`\n * - `fill`\n * - `stroke`\n * - `all`\n * - `inherit`\n * @memberof accessibility\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @memberof accessibility\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     */\n    accessibleTitle: string | null;\n    /** Sets the aria-label attribute of the shadow div */\n    accessibleHint: string | null;\n    /**\n     * @default 0\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     */\n    accessibleType: string;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {accessibility.PointerEvents}\n     */\n    accessiblePointerEvents: PointerEvents;\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    _accessibleActive: boolean;\n    _accessibleDiv: AccessibleHTMLElement | null;\n    _renderId: number;\n}\n\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @private\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @member {boolean}\n     * @memberof scene.Container#\n     */\n    accessible: false,\n\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleTitle: null,\n\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleHint: null,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @todo Needs docs.\n     */\n    tabIndex: 0,\n\n    /**\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleActive: false,\n\n    /**\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleDiv: null,\n\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @member {string}\n     * @memberof scene.Container#\n     * @default 'button'\n     */\n    accessibleType: 'button',\n\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @type {PointerEvents}\n     * @memberof scene.Container#\n     * @default 'auto'\n     */\n    accessiblePointerEvents: 'auto',\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @default true\n     */\n    accessibleChildren: true,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @private\n     */\n    _renderId: -1,\n};\n", "import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @memberof events\n * @class EventsTicker\n */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n}\n\nexport const EventsTicker = new EventsTickerClass();\n", "import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A {@link FederatedEvent} for mouse events.\n * @memberof events\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * This will return the local coordinates of the specified container for this InteractionData\n     * @param {Container} container - The Container that you would like the local\n     *  coords off\n     * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @returns - A point containing the coordinates of the InteractionData position relative\n     *  to the Container\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for pointer events.\n * @memberof events\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    // Only included for completeness for now\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    // Only included for completeness for now\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for wheel events.\n * @memberof events\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /** Units specified in pixels. */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in pixels. */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in lines. */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in lines. */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in pages. */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /** Units specified in pages. */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof events\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type = type ?? e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/** @ignore */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode mode for all display objects.\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     */\n    eventMode?: EventMode;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @example\n     * const app = new Application({\n     *   view: canvas,\n     *   events: {\n     *     move: true,\n     *     globalMove: false,\n     *     click: true,\n     *     wheel: true,\n     *   },\n     * });\n     */\n    eventFeatures?: Partial<EventSystemFeatures>\n}\n\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n * @memberof events\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     */\n    move: boolean;\n    // eslint-disable-next-line jsdoc/multiline-blocks\n    /**\n     * Enables global pointer move events:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchemove`\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking:\n     * - `pointerup` / `mouseup` / `touchend` / 'rightup'\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / 'rightupoutside'\n     * - `pointerdown` / 'mousedown' / `touchstart` / 'rightdown'\n     * - `click` / `tap`\n     */\n    click: boolean;\n    /** - Enables wheel events. */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events.\n * @memberof events\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event.\n     * Useful for getting the pointer position without listening to events.\n     * @since 7.2.0\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n", "import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\n *\n * Can be any valid CSS cursor value:\n * `auto`, `default`, `none`, `context-menu`, `help`, `pointer`, `progress`,\n * `wait`, `cell`, `crosshair`, `text`, `verticaltext`, `alias`, `copy`, `move`,\n * `nodrop`, `notallowed`, `eresize`, `nresize`, `neresize`, `nwresize`, `sresize`,\n *  `seresize`, `swresize`, `wresize`, `nsresize`, `ewresize`, `neswresize`, `colresize`,\n *  `nwseresize`, `rowresize`, `allscroll`, `zoomin`, `zoomout`, `grab`, `grabbing`\n * @memberof events\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * The hit area specifies the area for which pointer events should be captured by this event target.\n * @memberof events\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the x and y coordinates given are contained within this hit area.\n     * @returns Whether the x and y coordinates are contained within this hit area.\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @memberof events\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction a Container can be.\n * This is the {@link scene.Container#eventMode|Container.eventMode} property of any {@link scene.Container}.\n *\n * Can be one of the following:\n * - `'none'`: Ignores all interaction events, even on its children.\n * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n * allow for interaction when the mouse isn't moving\n *\n * `none` and `passive` are useful for optimizing interaction events on objects as it reduces the number of hit tests\n * PixiJS has to do. `auto` is useful for when you want to recreate how the DOM handles interaction events with\n * `pointer-events: auto`.\n * @since 7.2.0\n * @memberof events\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object.\n * @memberof events\n */\nexport interface FederatedOptions\n{\n    /** The cursor preferred when the mouse pointer is hovering over. */\n    cursor?: Cursor | string;\n    /** The mode of interaction for this object */\n    eventMode?: EventMode;\n    /** Whether this event target should fire UI events. */\n    interactive?: boolean\n    /** Whether this event target has any children that need UI events. This can be used optimize event propagation. */\n    interactiveChildren?: boolean;\n    /** The hit-area specifies the area for which pointer events should be captured by this event target. */\n    hitArea?: IHitArea | null;\n    /** Handler for 'click' event */\n    onclick?: FederatedEventHandler | null;\n    /** Handler for 'mousedown' event */\n    onmousedown?: FederatedEventHandler | null;\n    /** Handler for 'mouseenter' event */\n    onmouseenter?: FederatedEventHandler | null;\n    /** Handler for 'mouseleave' event */\n    onmouseleave?: FederatedEventHandler | null;\n    /** Handler for 'mousemove' event */\n    onmousemove?: FederatedEventHandler | null;\n    /** Handler for 'globalmousemove' event */\n    onglobalmousemove?: FederatedEventHandler | null;\n    /** Handler for 'mouseout' event */\n    onmouseout?: FederatedEventHandler | null;\n    /** Handler for 'mouseover' event */\n    onmouseover?: FederatedEventHandler | null;\n    /** Handler for 'mouseup' event */\n    onmouseup?: FederatedEventHandler | null;\n    /** Handler for 'mouseupoutside' event */\n    onmouseupoutside?: FederatedEventHandler | null;\n    /** Handler for 'pointercancel' event */\n    onpointercancel?: FederatedEventHandler | null;\n    /** Handler for 'pointerdown' event */\n    onpointerdown?: FederatedEventHandler | null;\n    /** Handler for 'pointerenter' event */\n    onpointerenter?: FederatedEventHandler | null;\n    /** Handler for 'pointerleave' event */\n    onpointerleave?: FederatedEventHandler | null;\n    /** Handler for 'pointermove' event */\n    onpointermove?: FederatedEventHandler | null;\n    /** Handler for 'globalpointermove' event */\n    onglobalpointermove?: FederatedEventHandler | null;\n    /** Handler for 'pointerout' event */\n    onpointerout?: FederatedEventHandler | null;\n    /** Handler for 'pointerover' event */\n    onpointerover?: FederatedEventHandler | null;\n    /** Handler for 'pointertap' event */\n    onpointertap?: FederatedEventHandler | null;\n    /** Handler for 'pointerup' event */\n    onpointerup?: FederatedEventHandler | null;\n    /** Handler for 'pointerupoutside' event */\n    onpointerupoutside?: FederatedEventHandler | null;\n    /** Handler for 'rightclick' event */\n    onrightclick?: FederatedEventHandler | null;\n    /** Handler for 'rightdown' event */\n    onrightdown?: FederatedEventHandler | null;\n    /** Handler for 'rightup' event */\n    onrightup?: FederatedEventHandler | null;\n    /** Handler for 'rightupoutside' event */\n    onrightupoutside?: FederatedEventHandler | null;\n    /** Handler for 'tap' event */\n    ontap?: FederatedEventHandler | null;\n    /** Handler for 'touchcancel' event */\n    ontouchcancel?: FederatedEventHandler | null;\n    /** Handler for 'touchend' event */\n    ontouchend?: FederatedEventHandler | null;\n    /** Handler for 'touchendoutside' event */\n    ontouchendoutside?: FederatedEventHandler | null;\n    /** Handler for 'touchmove' event */\n    ontouchmove?: FederatedEventHandler | null;\n    /** Handler for 'globaltouchmove' event */\n    onglobaltouchmove?: FederatedEventHandler | null;\n    /** Handler for 'touchstart' event */\n    ontouchstart?: FederatedEventHandler | null;\n    /** Handler for 'wheel' event */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\ntype AddListenerOptions = boolean | AddEventListenerOptions;\ntype RemoveListenerOptions = boolean | EventListenerOptions;\n\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    _internalEventMode: EventMode;\n\n    /** Returns true if the Container has interactive 'static' or 'dynamic' */\n    isInteractive: () => boolean;\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\nexport const FederatedContainer: IFederatedContainer = {\n\n    /**\n     * Property-based event handler for the `click` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onclick = (event) => {\n     *  //some function here that happens on click\n     * }\n     */\n    onclick: null,\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousedown = (event) => {\n     *  //some function here that happens on mousedown\n     * }\n     */\n    onmousedown: null,\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseenter = (event) => {\n     *  //some function here that happens on mouseenter\n     * }\n     */\n    onmouseenter: null,\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseleave = (event) => {\n     *  //some function here that happens on mouseleave\n     * }\n     */\n    onmouseleave: null,\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousemove = (event) => {\n     *  //some function here that happens on mousemove\n     * }\n     */\n    onmousemove: null,\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalmousemove = (event) => {\n     *  //some function here that happens on globalmousemove\n     * }\n     */\n    onglobalmousemove: null,\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseout = (event) => {\n     *  //some function here that happens on mouseout\n     * }\n     */\n    onmouseout: null,\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseover = (event) => {\n     *  //some function here that happens on mouseover\n     * }\n     */\n    onmouseover:  null,\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseup = (event) => {\n     *  //some function here that happens on mouseup\n     * }\n     */\n    onmouseup:  null,\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseupoutside = (event) => {\n     *  //some function here that happens on mouseupoutside\n     * }\n     */\n    onmouseupoutside: null,\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointercancel = (event) => {\n     *  //some function here that happens on pointercancel\n     * }\n     */\n    onpointercancel: null,\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerdown = (event) => {\n     *  //some function here that happens on pointerdown\n     * }\n     */\n    onpointerdown:  null,\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerenter = (event) => {\n     *  //some function here that happens on pointerenter\n     * }\n     */\n    onpointerenter: null,\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerleave = (event) => {\n     *  //some function here that happens on pointerleave\n     * }\n     */\n    onpointerleave:  null,\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointermove = (event) => {\n     *  //some function here that happens on pointermove\n     * }\n     */\n    onpointermove:  null,\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalpointermove = (event) => {\n     *  //some function here that happens on globalpointermove\n     * }\n     */\n    onglobalpointermove:  null,\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerout = (event) => {\n     *  //some function here that happens on pointerout\n     * }\n     */\n    onpointerout:  null,\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerover = (event) => {\n     *  //some function here that happens on pointerover\n     * }\n     */\n    onpointerover:  null,\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointertap = (event) => {\n     *  //some function here that happens on pointertap\n     * }\n     */\n    onpointertap:  null,\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerup = (event) => {\n     *  //some function here that happens on pointerup\n     * }\n     */\n    onpointerup:  null,\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerupoutside = (event) => {\n     *  //some function here that happens on pointerupoutside\n     * }\n     */\n    onpointerupoutside:  null,\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightclick = (event) => {\n     *  //some function here that happens on rightclick\n     * }\n     */\n    onrightclick:  null,\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightdown = (event) => {\n     *  //some function here that happens on rightdown\n     * }\n     */\n    onrightdown:  null,\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightup = (event) => {\n     *  //some function here that happens on rightup\n     * }\n     */\n    onrightup:  null,\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightupoutside = (event) => {\n     *  //some function here that happens on rightupoutside\n     * }\n     */\n    onrightupoutside:  null,\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontap = (event) => {\n     *  //some function here that happens on tap\n     * }\n     */\n    ontap:  null,\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchcancel = (event) => {\n     *  //some function here that happens on touchcancel\n     * }\n     */\n    ontouchcancel:  null,\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchend = (event) => {\n     *  //some function here that happens on touchend\n     * }\n     */\n    ontouchend:  null,\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchendoutside = (event) => {\n     *  //some function here that happens on touchendoutside\n     * }\n     */\n    ontouchendoutside:  null,\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchmove = (event) => {\n     *  //some function here that happens on touchmove\n     * }\n     */\n    ontouchmove:  null,\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobaltouchmove = (event) => {\n     *  //some function here that happens on globaltouchmove\n     * }\n     */\n    onglobaltouchmove:  null,\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchstart = (event) => {\n     *  //some function here that happens on touchstart\n     * }\n     */\n    ontouchstart:  null,\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onwheel = (event) => {\n     *  //some function here that happens on wheel\n     * }\n     */\n    onwheel:  null,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse\n     * @memberof scene.Container#\n     */\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    /**\n     * @ignore\n     */\n    _internalEventMode: undefined,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse.\n     * There are 5 types of interaction settings:\n     * - `'none'`: Ignores all interaction events, even on its children.\n     * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n     * Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n     * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n     * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n     * allow for interaction when the mouse isn't moving\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.on('tap', (event) => {\n     *     // Handle event\n     * });\n     * @memberof scene.Container#\n     * @since 7.2.0\n     */\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @memberof scene.Container#\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n\n    /**\n     * Determines if the children to the container can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     * @memberof scene.Container#\n     */\n    interactiveChildren: true,\n\n    /**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.\n     * @example\n     * import { Rectangle, Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n     * @member {IHitArea}\n     * @memberof scene.Container#\n     */\n    hitArea: null,\n\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event to listen to.\n     * @param listener - The listener callback or object.\n     * @param options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event the listener is bound to.\n     * @param listener - The listener callback or object.\n     * @param options - The original listener options. This is required to deregister a capture phase listener.\n     */\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @memberof scene.Container\n     * @param e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n"],
  "mappings": "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",
  "names": ["navigator", "isMobile", "isMobile", "type", "_EventSystem", "nativeEvent"]
}
